====RUBY=====
# Taylor Series
def a
   [ 1.00000_00000_00000_00000,  0.57721_56649_01532_86061, -0.65587_80715_20253_88108,
    -0.04200_26350_34095_23553,  0.16653_86113_82291_48950, -0.04219_77345_55544_33675,
    -0.00962_19715_27876_97356,  0.00721_89432_46663_09954, -0.00116_51675_91859_06511,
    -0.00021_52416_74114_95097,  0.00012_80502_82388_11619, -0.00002_01348_54780_78824,
    -0.00000_12504_93482_14267,  0.00000_11330_27231_98170, -0.00000_02056_33841_69776,
     0.00000_00061_16095_10448,  0.00000_00050_02007_64447, -0.00000_00011_81274_57049,
     0.00000_00001_04342_67117,  0.00000_00000_07782_26344, -0.00000_00000_03696_80562,
     0.00000_00000_00510_03703, -0.00000_00000_00020_58326, -0.00000_00000_00005_34812,
     0.00000_00000_00001_22678, -0.00000_00000_00000_11813,  0.00000_00000_00000_00119,
     0.00000_00000_00000_00141, -0.00000_00000_00000_00023,  0.00000_00000_00000_00002 ]
end
 
def taylor_gamma(x)
  y = x.to_f - 1
  1.0 / a.reverse.reduce(0) { |sum, an| sum * y + an }
end
 
# Lanczos Method
def p
  [ 0.99999_99999_99809_93, 676.52036_81218_851, -1259.13921_67224_028, 
    771.32342_87776_5313, -176.61502_91621_4059,  12.50734_32786_86905, 
    -0.13857_10952_65720_12, 9.98436_95780_19571_6e-6, 1.50563_27351_49311_6e-7 ]
end
 
def lanczos_gamma(z)
  # Reflection formula
  z = z.to_f
  if z < 0.5
    Math::PI / (Math.sin(Math::PI * z) * lanczos_gamma(1 - z))
  else
    z -= 1
    x = p[0]
    (1..p.size - 1).each { |i| x += p[i] / (z + i) }
    t = z + p.size - 1.5
    Math.sqrt(2 * Math::PI) * t**(z + 0.5) * Math.exp(-t) * x
  end
end
 
puts "                Taylor Series         Lanczos Method        Builtin Function"
(1..27).each { |i| n = i/3.0; puts "gamma(%.2f) = %.14e  %.14e  %.14e" % [n, taylor_gamma(n), lanczos_gamma(n), Math.gamma(n)] }
 

====RUBY=====
$a = [ 1.00000_00000_00000_00000,  0.57721_56649_01532_86061, -0.65587_80715_20253_88108,
      -0.04200_26350_34095_23553,  0.16653_86113_82291_48950, -0.04219_77345_55544_33675,
      -0.00962_19715_27876_97356,  0.00721_89432_46663_09954, -0.00116_51675_91859_06511,
      -0.00021_52416_74114_95097,  0.00012_80502_82388_11619, -0.00002_01348_54780_78824,
      -0.00000_12504_93482_14267,  0.00000_11330_27231_98170, -0.00000_02056_33841_69776,
       0.00000_00061_16095_10448,  0.00000_00050_02007_64447, -0.00000_00011_81274_57049,
       0.00000_00001_04342_67117,  0.00000_00000_07782_26344, -0.00000_00000_03696_80562,
       0.00000_00000_00510_03703, -0.00000_00000_00020_58326, -0.00000_00000_00005_34812,
       0.00000_00000_00001_22678, -0.00000_00000_00000_11813,  0.00000_00000_00000_00119,
       0.00000_00000_00000_00141, -0.00000_00000_00000_00023,  0.00000_00000_00000_00002 ]
 
def gamma(x)
  y = Float(x) - 1
  1.0 / $a.reverse.inject {|sum, an| sum * y + an}
end
 
(1..10).each {|i| puts format("%.14e", gamma(i/3.0))}

====RUBY=====
(1..10).each{|i| puts Math.gamma(i/3.0)}

====RUBY=====
var a = [ 1.00000_00000_00000_00000,  0.57721_56649_01532_86061, -0.65587_80715_20253_88108,
         -0.04200_26350_34095_23553,  0.16653_86113_82291_48950, -0.04219_77345_55544_33675,
         -0.00962_19715_27876_97356,  0.00721_89432_46663_09954, -0.00116_51675_91859_06511,
         -0.00021_52416_74114_95097,  0.00012_80502_82388_11619, -0.00002_01348_54780_78824,
         -0.00000_12504_93482_14267,  0.00000_11330_27231_98170, -0.00000_02056_33841_69776,
          0.00000_00061_16095_10448,  0.00000_00050_02007_64447, -0.00000_00011_81274_57049,
          0.00000_00001_04342_67117,  0.00000_00000_07782_26344, -0.00000_00000_03696_80562,
          0.00000_00000_00510_03703, -0.00000_00000_00020_58326, -0.00000_00000_00005_34812,
          0.00000_00000_00001_22678, -0.00000_00000_00000_11813,  0.00000_00000_00000_00119,
          0.00000_00000_00000_00141, -0.00000_00000_00000_00023,  0.00000_00000_00000_00002 ]
 
func gamma(x) {
    var y = (x - 1)
    1 / a.reverse.reduce {|sum, an| sum*y + an}
}
 
for i in 1..10 {
    say ("%.14e" % gamma(i/3))
}

====RUBY=====
func gamma(z) {
    var epsilon = 0.0000001
    func withinepsilon(x) {
        abs(x - abs(x)) <= epsilon
    }
 
    var p = [
        676.5203681218851,     -1259.1392167224028,
        771.32342877765313,    -176.61502916214059,
        12.507343278686905,    -0.13857109526572012,
        9.9843695780195716e-6,  1.5056327351493116e-7,
    ]
 
    var result = 0
    const pi = Num.pi
 
    if (z.re < 0.5) {
        result = (pi / (sin(pi * z) * gamma(1 - z)))
    }
    else {
        z -= 1
        var x = 0.99999999999980993
 
        p.each_kv { |i, v|
            x += v/(z + i + 1)
        }
 
        var t = (z + p.len - 0.5)
        result = (sqrt(pi*2) * t**(z+0.5) * exp(-t) * x)
    }
 
    withinepsilon(result.im) ? result.re : result
}
 
for i in 1..10 {
    say ("%.14e" % gamma(i/3))
}

====RUBY=====
define ℯ = Num.e
define τ = Num.tau
 
func Γ(t) {
    t < 20 ? (__FUNC__(t + 1) / t)
           : (sqrt(τ*t) * pow(t/ℯ + 1/(12*ℯ*t), t) / t)
}
 
for i in (1..10) {
    say ("%.14e" % Γ(i/3))
}

====PYTHON=====
_a =    ( 1.00000000000000000000, 0.57721566490153286061, -0.65587807152025388108,
         -0.04200263503409523553, 0.16653861138229148950, -0.04219773455554433675,
         -0.00962197152787697356, 0.00721894324666309954, -0.00116516759185906511,
         -0.00021524167411495097, 0.00012805028238811619, -0.00002013485478078824,
         -0.00000125049348214267, 0.00000113302723198170, -0.00000020563384169776,
          0.00000000611609510448, 0.00000000500200764447, -0.00000000118127457049,
          0.00000000010434267117, 0.00000000000778226344, -0.00000000000369680562,
          0.00000000000051003703, -0.00000000000002058326, -0.00000000000000534812,
          0.00000000000000122678, -0.00000000000000011813, 0.00000000000000000119,
          0.00000000000000000141, -0.00000000000000000023, 0.00000000000000000002
       )
def gamma (x): 
   y  = float(x) - 1.0;
   sm = _a[-1];
   for an in _a[-2::-1]:
      sm = sm * y + an;
   return 1.0 / sm;
 
 
if __name__ == '__main__':
    for i in range(1,11):
        print "  %20.14e" % gamma(i/3.0)
 

====PYTHON=====
'''Gamma function'''
 
from functools import reduce
 
 
# gamma_ :: [Float] -> Float -> Float
def gamma_(tbl):
    '''Gamma function.'''
    def go(x):
        y = float(x) - 1.0
        return 1.0 / reduce(
            lambda a, x: a * y + x,
            tbl[-2::-1],
            tbl[-1]
        )
    return lambda x: go(x)
 
 
# TBL :: [Float]
TBL = [
    1.00000000000000000000, 0.57721566490153286061,
    -0.65587807152025388108, -0.04200263503409523553,
    0.16653861138229148950, -0.04219773455554433675,
    -0.00962197152787697356, 0.00721894324666309954,
    -0.00116516759185906511, -0.00021524167411495097,
    0.00012805028238811619, -0.00002013485478078824,
    -0.00000125049348214267, 0.00000113302723198170,
    -0.00000020563384169776, 0.00000000611609510448,
    0.00000000500200764447, -0.00000000118127457049,
    0.00000000010434267117, 0.00000000000778226344,
    -0.00000000000369680562, 0.00000000000051003703,
    -0.00000000000002058326, -0.00000000000000534812,
    0.00000000000000122678, -0.00000000000000011813,
    0.00000000000000000119, 0.00000000000000000141,
    -0.00000000000000000023, 0.00000000000000000002
]
 
 
# TEST ----------------------------------------------------
# main :: IO()
def main():
    '''Gamma function over a range of values.'''
 
    gamma = gamma_(TBL)
    print(
        fTable(' i -> gamma(i/3):\n')(repr)(lambda x: "%0.7e" % x)(
            lambda x: gamma(x / 3.0)
        )(enumFromTo(1)(10))
    )
 
 
# GENERIC -------------------------------------------------
 
# enumFromTo :: (Int, Int) -> [Int]
def enumFromTo(m):
    '''Integer enumeration from m to n.'''
    return lambda n: list(range(m, 1 + n))
 
 
# FORMATTING -------------------------------------------------
 
# fTable :: String -> (a -> String) ->
#                     (b -> String) -> (a -> b) -> [a] -> String
def fTable(s):
    '''Heading -> x display function -> fx display function ->
                     f -> xs -> tabular string.
    '''
    def go(xShow, fxShow, f, xs):
        ys = [xShow(x) for x in xs]
        w = max(map(len, ys))
        return s + '\n' + '\n'.join(map(
            lambda x, y: y.rjust(w, ' ') + ' -> ' + fxShow(f(x)),
            xs, ys
        ))
    return lambda xShow: lambda fxShow: lambda f: lambda xs: go(
        xShow, fxShow, f, xs
    )
 
 
# MAIN ---
if __name__ == '__main__':
    main()

====PYTHON=====
from mpmath import mp
 
mp.dps = 50
 
def gamma_coef(n):
    a = [mp.mpf(1), mp.mpf(mp.euler)]
    for k in range(3, n + 1):
        s = sum((-1)**j * mp.zeta(j) * a[k - j - 1] for j in range(2, k))
        a.append((s - a[1] * a[k - 2]) / (1 - k * a[0]))
    return a
 
def horner(a, x):
    y = 0
    for s in reversed(a):
        y = y * x + s
    return y
 
gc = gamma_coef(30)
 
def gamma_approx(x):
    y = mp.mpf(1)
    while x < 0.5:
        y /= x
        x += 1
    while x > 1.5:
        x -= 1
        y *= x
    return y / horner(gc, x - 1)
 
for x in gc:
    print(mp.nstr(x, 25))

