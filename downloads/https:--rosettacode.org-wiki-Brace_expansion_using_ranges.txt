====PYTHON=====
Â 
"""Brace range expansion. Requires Python >=3.6.
Â 
Here we use regular expressions for parsing and take an object orientated approach
to expansion of range expressions.
Â 
NOTE: With my current version of bash (GNU bash, version 5.0.3(1)-release), a ``-``
or ``+`` character in front of a `step` has no effect. This implementation reverses
the range if a ``-`` immediately precedes a step, and does not recognize range
expressions that use a ``+``.
Â 
NOTE: This implementation supports stepped ordinal range expressions.
"""
Â 
from __future__ import annotations
Â 
import itertools
import re
Â 
from abc import ABC
from abc import abstractmethod
Â 
from typing import Iterable
from typing import Optional
Â 
Â 
RE_SPEC = [
    (
        "INT_RANGE",
        r"\{(?P<int_start>[0-9]+)..(?P<int_stop>[0-9]+)(?:(?:..)?(?P<int_step>-?[0-9]+))?}",
    ),
    (
        "ORD_RANGE",
        r"\{(?P<ord_start>[^0-9])..(?P<ord_stop>[^0-9])(?:(?:..)?(?P<ord_step>-?[0-9]+))?}",
    ),
    (
        "LITERAL",
        r".+?(?=\{|$)",
    ),
]
Â 
Â 
RE_EXPRESSION = re.compile(
    "|".join(rf"(?P<{name}>{pattern})" for name, pattern in RE_SPEC)
)
Â 
Â 
class Expression(ABC):
    """Brace expression abstract base class."""
Â 
    @abstractmethod
    def expand(self, prefix: str) -> Iterable[str]:
        pass
Â 
Â 
class Literal(Expression):
    """An expression literal."""
Â 
    def __init__(self, value: str):
        self.value = value
Â 
    def expand(self, prefix: str) -> Iterable[str]:
        return [f"{prefix}{self.value}"]
Â 
Â 
class IntRange(Expression):
    """An integer range expression."""
Â 
    def __init__(
        self, start: int, stop: int, step: Optional[int] = None, zfill: int = 0
    ):
        self.start, self.stop, self.step = fix_range(start, stop, step)
        self.zfill = zfill
Â 
    def expand(self, prefix: str) -> Iterable[str]:
        return (
            f"{prefix}{str(i).zfill(self.zfill)}"
            for i in range(self.start, self.stop, self.step)
        )
Â 
Â 
class OrdRange(Expression):
    """An ordinal range expression."""
Â 
    def __init__(self, start: str, stop: str, step: Optional[int] = None):
        self.start, self.stop, self.step = fix_range(ord(start), ord(stop), step)
Â 
    def expand(self, prefix: str) -> Iterable[str]:
        return (f"{prefix}{chr(i)}" for i in range(self.start, self.stop, self.step))
Â 
Â 
def expand(expressions: Iterable[Expression]) -> Iterable[str]:
    """Expand a sequence of ``Expression``s. Each expression builds on the results
    of the expressions that come before it in the sequence."""
    expanded = [""]
Â 
    for expression in expressions:
        expanded = itertools.chain.from_iterable(
            [expression.expand(prefix) for prefix in expanded]
        )
Â 
    return expanded
Â 
Â 
def zero_fill(start, stop) -> int:
    """Return the target zero padding width."""
Â 
    def _zfill(s):
        if len(s) <= 1 or not s.startswith("0"):
            return 0
        return len(s)
Â 
    return max(_zfill(start), _zfill(stop))
Â 
Â 
def fix_range(start, stop, step):
    """Transform start, stop and step so that we can pass them to Python's
    built-in ``range`` function."""
    if not step:
        # Zero or None. Explicit zero gets changed to default.
        if start <= stop:
            # Default step for ascending ranges.
            step = 1
        else:
            # Default step for descending ranges.
            step = -1
Â 
    elif step < 0:
        # A negative step means we reverse the range.
        start, stop = stop, start
        step = abs(step)
Â 
    elif start > stop:
        # A descending range with explicit step.
        step = -step
Â 
    # Don't overshoot or fall short.
    if (start - stop)Â % step == 0:
        stop += step
Â 
    return start, stop, step
Â 
Â 
def parse(expression: str) -> Iterable[Expression]:
    """Generate a sequence of ``Expression``s from the given range expression."""
    for match in RE_EXPRESSION.finditer(expression):
        kind = match.lastgroup
Â 
        if kind == "INT_RANGE":
            start = match.group("int_start")
            stop = match.group("int_stop")
            step = match.group("int_step")
            zfill = zero_fill(start, stop)
Â 
            if step is not None:
                step = int(step)
Â 
            yield IntRange(int(start), int(stop), step, zfill=zfill)
Â 
        elif kind == "ORD_RANGE":
            start = match.group("ord_start")
            stop = match.group("ord_stop")
            step = match.group("ord_step")
Â 
            if step is not None:
                step = int(step)
Â 
            yield OrdRange(start, stop, step)
Â 
        elif kind == "LITERAL":
            yield Literal(match.group())
Â 
Â 
def examples():
    cases = [
        r"simpleNumberRising{1..3}.txt",
        r"steppedNumberRising{1..6..2}.txt",
        r"steppedNumberDescending{20..9..2}.txt",
        r"simpleAlphaDescending-{Z..X}.txt",
        r"steppedDownAndPadded-{10..00..5}.txt",
        r"minusSignFlipsSequence {030..20..-5}.txt",
        r"combined-{Q..P}{2..1}.txt",
        r"emoji{ðŸŒµ..ðŸŒ¶}{ðŸŒ½..ðŸŒ¾}etc",
        r"li{teral",
        r"rangeless{random}string",
        r"rangeless{}empty",
        r"steppedAlphaDescending-{Z..M..2}.txt",
        r"reversedSteppedAlphaDescending-{Z..M..-2}.txt",
    ]
Â 
    for case in cases:
        print(f"{case} ->")
        expressions = parse(case)
Â 
        for itm in expand(expressions):
            print(f"{' '*4}{itm}")
Â 
        print("")  # Blank line between cases
Â 
Â 
if __name__ == "__main__":
    examples()
Â 

