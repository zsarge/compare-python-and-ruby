====RUBY=====
class Integer
  def narcissistic?
    return false if negative?
    digs = self.digits    
    m    = digs.size
    digs.map{|d| d**m}.sum == self
  end
end
 
puts 0.step.lazy.select(&:narcissistic?).first(25)

====RUBY=====
func is_narcissistic(n) {
    n.digits »**» n.len -> sum == n
}
 
var count = 0
for i in ^Inf {
    if (is_narcissistic(i)) {
        say "#{++count}\t#{i}"
        break if (count == 25)
    }
}

====PYTHON=====
from __future__ import print_function
from itertools import count, islice
 
def narcissists():
    for digits in count(0):
        digitpowers = [i**digits for i in range(10)]
        for n in range(int(10**(digits-1)), 10**digits):
            div, digitpsum = n, 0
            while div:
                div, mod = divmod(div, 10)
                digitpsum += digitpowers[mod]
            if n == digitpsum:
                yield n
 
for i, n in enumerate(islice(narcissists(), 25), 1):
    print(n, end=' ')
    if i % 5 == 0: print() 
print()

====PYTHON=====
try:
    import psyco
    psyco.full()
except:
    pass
 
class Narcissistics:
    def __init__(self, max_len):
        self.max_len = max_len
        self.power = [0] * 10
        self.dsum = [0] * (max_len + 1)
        self.count = [0] * 10
        self.len = 0
        self.ord0 = ord('0')
 
    def check_perm(self, out = [0] * 10):
        for i in xrange(10):
            out[i] = 0
 
        s = str(self.dsum[0])
        for d in s:
            c = ord(d) - self.ord0
            out[c] += 1
            if out[c] > self.count[c]:
                return
 
        if len(s) == self.len:
            print self.dsum[0],
 
    def narc2(self, pos, d):
        if not pos:
            self.check_perm()
            return
 
        while True:
            self.dsum[pos - 1] = self.dsum[pos] + self.power[d]
            self.count[d] += 1
            self.narc2(pos - 1, d)
            self.count[d] -= 1
            if d == 0:
                break
            d -= 1
 
    def show(self, n):
        self.len = n
        for i in xrange(len(self.power)):
            self.power[i] = i ** n
        self.dsum[n] = 0
        print "length %d:" % n,
        self.narc2(n, 9)
        print
 
def main():
    narc = Narcissistics(14)
    for i in xrange(1, narc.max_len + 1):
        narc.show(i)
 
main()

====PYTHON=====
'''Narcissistic decimal numbers'''
 
from itertools import chain
from functools import reduce
 
 
# main :: IO ()
def main():
    '''Narcissistic numbers of digit lengths 1 to 7'''
    print(
        fTable(main.__doc__ + ':\n')(str)(str)(
            narcissiOfLength
        )(enumFromTo(1)(7))
    )
 
 
# narcissiOfLength :: Int -> [Int]
def narcissiOfLength(n):
    '''List of Narcissistic numbers of
       (base 10) digit length n.
    '''
    return [
        x for x in digitPowerSums(n)
        if isDaffodil(n)(x)
    ]
 
 
# digitPowerSums :: Int -> [Int]
def digitPowerSums(e):
    '''The subset of integers of e digits that are potential narcissi.
       (Flattened leaves of a tree of unique digit combinations, in which
       order is not significant. The sum is independent of the sequence.)
    '''
    powers = [(x, x ** e) for x in enumFromTo(0)(9)]
 
    def go(n, parents):
        return go(
            n - 1,
            chain.from_iterable(map(
                lambda pDigitSum: (
                    map(
                        lambda lDigitSum: (
                            lDigitSum[0],
                            lDigitSum[1] + pDigitSum[1]
                        ),
                        powers[0: 1 + pDigitSum[0]]
                    )
                ),
                parents
            )) if parents else powers
        ) if 0 < n else parents
 
    return [xs for (_, xs) in go(e, [])]
 
 
# isDaffodil :: Int -> Int -> Bool
def isDaffodil(e):
    '''True if n is a narcissistic number
       of decimal digit length e.
    '''
    def go(n):
        ds = digitList(n)
        return e == len(ds) and n == powerSum(e)(ds)
    return lambda n: go(n)
 
 
# powerSum :: Int -> [Int] -> Int
def powerSum(e):
    '''The sum of a list obtained by raising
       each element of xs to the power of e.
    '''
    return lambda xs: reduce(
        lambda a, x: a + x ** e,
        xs, 0
    )
 
 
# -----------------------FORMATTING------------------------
 
# fTable :: String -> (a -> String) ->
# (b -> String) -> (a -> b) -> [a] -> String
def fTable(s):
    '''Heading -> x display function -> fx display function ->
       f -> xs -> tabular string.
    '''
    def go(xShow, fxShow, f, xs):
        ys = [xShow(x) for x in xs]
        w = max(map(len, ys))
        return s + '\n' + '\n'.join(map(
            lambda x, y: y.rjust(w, ' ') + ' -> ' + fxShow(f(x)),
            xs, ys
        ))
    return lambda xShow: lambda fxShow: lambda f: lambda xs: go(
        xShow, fxShow, f, xs
    )
 
 
# GENERIC -------------------------------------------------
 
# digitList :: Int -> [Int]
def digitList(n):
    '''A decomposition of n into a
       list of single-digit integers.
    '''
    def go(x):
        return go(x // 10) + [x % 10] if x else []
    return go(n) if n else [0]
 
 
# enumFromTo :: Int -> Int -> [Int]
def enumFromTo(m):
    '''Enumeration of integer values [m..n]'''
    def go(n):
        return list(range(m, 1 + n))
    return lambda n: go(n)
 
 
# MAIN ---
if __name__ == '__main__':
    main()

