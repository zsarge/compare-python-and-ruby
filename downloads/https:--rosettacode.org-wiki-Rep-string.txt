====RUBY=====
def rep(sÂ : String)Â : Int32
  x = s.size // 2
Â 
  while x > 0
    return x if s.starts_with? s[x..]
    x -= 1
  end
Â 
  0
end
Â 
def main
  %w(
    1001110011
    1110111011
    0010010010
    1010101010
    1111111111
    0100101101
    0100100
    101
    11
    00
    1
  ).each do |s|
    n = rep s
    puts n > 0Â ? "\"#{s}\" #{n} rep-string \"#{s[..(n - 1)]}\""Â : "\"#{s}\" not a rep-string"
  end
end
Â 
main
Â 

====RUBY=====
ar = %w(1001110011
        1110111011
        0010010010
        1010101010
        1111111111
        0100101101
        0100100
        101
        11
        00
        1)
Â 
ar.each do |str|
  rep_pos = (str.size/2).downto(1).find{|pos| str.start_with? str[pos..-1]}
  puts str, rep_posÂ ? " "*rep_pos + str[0, rep_pos]Â : "(no repetition)", ""
end

====RUBY=====
var arr = <1001110011 1110111011
           0010010010 1010101010
           1111111111 0100101101
           0100100  101  11 00 1>;
Â 
 arr.each { |n|
    if (var m = /^(.+)\1+(.*$)(?(?{ substr($1, 0, length $2) eq $2 })|(?!))/.match(n)) {
       var i = m[0].len;
       say (n.substr(0, i),
            n.substr(i, i).tr('01', 'ðŸ˜ðŸ™'),
            n.substr(i*2));
    } else {
        say "#{n} (no repeat)";
    }
}

====PYTHON=====
def is_repeated(text):
    'check if the first part of the string is repeated throughout the string'
    for x in range(len(text)//2, 0, -1):
        if text.startswith(text[x:]): return x
    return 0
Â 
matchstr = """\
1001110011
1110111011
0010010010
1010101010
1111111111
0100101101
0100100
101
11
00
1
"""
for line in matchstr.split():
    ln = is_repeated(line)
    print('%r has a repetition length ofÂ %i i.e.Â %s' 
          Â % (line, ln, repr(line[:ln]) if ln else '*not* a rep-string'))

====PYTHON=====
>>> def reps(text):
    return [text[:x] for x in range(1, 1 + len(text) // 2)
            if text.startswith(text[x:])]
Â 
>>> matchstr = """\
1001110011
1110111011
0010010010
1010101010
1111111111
0100101101
0100100
101
11
00
1
"""
>>> print('\n'.join('%r has repsÂ %r'Â % (line, reps(line)) for line in matchstr.split()))
'1001110011' has reps ['10011']
'1110111011' has reps ['1110']
'0010010010' has reps ['001']
'1010101010' has reps ['10', '1010']
'1111111111' has reps ['1', '11', '111', '1111', '11111']
'0100101101' has reps []
'0100100' has reps ['010']
'101' has reps []
'11' has reps ['1']
'00' has reps ['0']
'1' has reps []
>>> 

====PYTHON=====
'''Rep-strings'''
Â 
from itertools import (accumulate, chain, cycle, islice)
Â 
Â 
# repCyclesÂ :: String -> [String]
def repCycles(s):
    '''Repeated sequences of characters in s.'''
    n = len(s)
    cs = list(s)
Â 
    return [
        x for x in
        tail(inits(take(n // 2)(s)))
        if cs == take(n)(cycle(x))
    ]
Â 
Â 
# TEST ----------------------------------------------------
# mainÂ :: IO ()
def main():
    '''Tests - longest cycle (if any) in each string.'''
    print(
        fTable('Longest cycles:\n')(repr)(
            lambda xs: ''.join(xs[-1]) if xs else '(none)'
        )(repCycles)([
            '1001110011',
            '1110111011',
            '0010010010',
            '1010101010',
            '1111111111',
            '0100101101',
            '0100100',
            '101',
            '11',
            '00',
            '1',
        ])
    )
Â 
Â 
# GENERIC -------------------------------------------------
Â 
# initsÂ :: [a] -> [[a]]
def inits(xs):
    '''all initial segments of xs, shortest first.'''
    return accumulate(chain([[]], xs), lambda a, x: a + [x])
Â 
Â 
# tailÂ :: [a] -> [a]
# tailÂ :: Gen [a] -> [a]
def tail(xs):
    '''The elements following the head of a
       (non-empty) list or generator stream.'''
    if isinstance(xs, list):
        return xs[1:]
    else:
        list(islice(xs, 1))  # First item dropped.
        return xs
Â 
Â 
# takeÂ :: Int -> [a] -> [a]
# takeÂ :: Int -> String -> String
def take(n):
    '''The prefix of xs of length n,
       or xs itself if n > length xs.'''
    return lambda xs: (
        xs[0:n]
        if isinstance(xs, (list, tuple))
        else list(islice(xs, n))
    )
Â 
Â 
# OUTPUT FORMATTING ---------------------------------------
Â 
# fTableÂ :: String -> (a -> String) ->
#                     (b -> String) -> (a -> b) -> [a] -> String
def fTable(s):
    '''Heading -> x display function ->
                 fx display function ->
          f -> value list -> tabular string.
    '''
    def go(xShow, fxShow, f, xs):
        ys = [xShow(x) for x in xs]
        w = max(map(len, ys))
        return s + '\n' + '\n'.join(map(
            lambda x, y: y.rjust(w, ' ') + ' -> ' + fxShow(f(x)),
            xs, ys
        ))
    return lambda xShow: lambda fxShow: lambda f: lambda xs: go(
        xShow, fxShow, f, xs
    )
Â 
Â 
# MAIN ---
if __name__ == '__main__':
    main()

====PYTHON=====
import re
Â 
matchstr = """\
1001110011
1110111011
0010010010
1010101010
1111111111
0100101101
0100100
101
11
00
1"""
Â 
def _checker(matchobj):
    g0, (g1, g2, g3, g4) = matchobj.group(0), matchobj.groups()
    if not g4 and g1 and g1.startswith(g3):
        return '%r repeatsÂ %r'Â % (g0, g1)
    return '%r is not a rep-string'Â % (g0,)
Â 
def checkit(txt):
    print(re.sub(r'(.+)(\1+)(.*)|(.*)', _checker, txt))
Â 
checkit(matchstr)

